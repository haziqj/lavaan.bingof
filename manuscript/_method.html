<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>method</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="_method_files/libs/clipboard/clipboard.min.js"></script>
<script src="_method_files/libs/quarto-html/quarto.js"></script>
<script src="_method_files/libs/quarto-html/popper.min.js"></script>
<script src="_method_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_method_files/libs/quarto-html/anchor.min.js"></script>
<link href="_method_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_method_files/libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_method_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_method_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_method_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="multinomial-representation" class="level3">
<h3 class="anchored" data-anchor-id="multinomial-representation">Multinomial representation</h3>
<p>Let <span class="math inline">\({\mathbf Y}= (Y_1,\dots,Y_p)^\top\)</span> be a vector of ordinal variables such that each <span class="math inline">\(Y_i\)</span> takes one and only one value from the set <span class="math inline">\(\{0,1,\dots,m_i-1\}\)</span>. We can assume a multinoulli distribution for each <span class="math inline">\(Y_i\)</span>, for which the joint distribution is <span class="math display">\[
\operatorname{P}({\mathbf Y}= {\mathbf y}) = \operatorname{P}(Y_1 = y_1, \dots, Y_p = y_p).
\]</span> Note that there are a total of <span class="math inline">\(R=\prod_{i=1}^p m_i\)</span> possible joint probabilities corresponding to all possible response patterns of the form <span class="math inline">\({\mathbf y}= (y_1,\dots,y_p)\)</span>, where <span class="math inline">\(y_i = 1,\dots,m_i\)</span>. The sum of all response probabilities must equal one.</p>
<!-- Each component of this vector can be marginalised to obtain the univariate probabilities -->
<!-- univariate probabilities... -->
<!-- bivariate probabilities... -->
<!-- can go more than this, tetravariate and beyond, but stop here. -->
<!-- GOAL: Explain $\bpi_2 = [\dot\bpi_1, \dot\bpi_2]$. -->
<p>Suppose that <span class="math inline">\({\mathcal Y}= \{ {\mathbf y}^{(h)} \}\)</span> is an independent and identically distributed (iid) sample of size <span class="math inline">\(n\)</span> from the distribution of <span class="math inline">\({\mathbf Y}\)</span>. Let <span class="math inline">\(p_r = \hat n_r / n\)</span> be the <span class="math inline">\(r\)</span>th entry of the <span class="math inline">\(R\)</span>-vector of proportions <span class="math inline">\({\mathbf p}\)</span>, with <span class="math inline">\(\hat n_r\)</span> denoting the frequency of the occurence of the response pattern <span class="math inline">\({\mathbf y}_r\)</span> in the sample <span class="math inline">\({\mathcal Y}\)</span>. The random vector <span class="math inline">\(\hat{\mathbf n}= (\hat n_1,\dots,\hat n_R)^\top\)</span> follows a multinomial distribution with parameters <span class="math inline">\(n\)</span>, <span class="math inline">\(R\)</span>, and <span class="math inline">\({\boldsymbol\pi}= ({\boldsymbol\pi}_1,\dots,{\boldsymbol\pi}_R)^\top\)</span>. The mean of <span class="math inline">\({\mathbf n}\)</span> is <span class="math inline">\(\mathop{\mathrm{E}}({\mathbf n}) = n{\mathbf p}\)</span>, while the variance-covariance matrix of <span class="math inline">\({\mathbf n}\)</span> is <span class="math display">\[
\mathop{\mathrm{Var}}(\hat{\mathbf n}) = n \big( \mathop{\mathrm{diag}}({\boldsymbol\pi}) -  {\boldsymbol\pi}{\boldsymbol\pi}^\top \big) =: n{\boldsymbol\Sigma}.
\]</span> It is widely known, as a consequence of the central limit theorem, that for iid samples, <span class="math display">\[
\sqrt n ({\mathbf p}- {\boldsymbol\pi}) \xrightarrow{\text D} {\mathop{\mathrm{N}}}_R({\mathbf 0}, {\boldsymbol\Sigma}).
\]</span> See <span class="citation" data-cites="agresti2002categorical">(<a href="#ref-agresti2002categorical" role="doc-biblioref">Agresti 2002</a>)</span> for more details. This limiting result serves as one of the ingredients for the derivation of the goodness-of-fit tests for categorical data, as we will see later on.</p>
</section>
<section id="cfa-with-ordinal-items" class="level3">
<h3 class="anchored" data-anchor-id="cfa-with-ordinal-items">CFA with ordinal items</h3>
<p>To describe a factor model for ordinal items, consider the following <em>underlying variable</em> setup. Each observed ordinal response <span class="math inline">\(Y_i\)</span> is assumed to be manifested due to the thresholding of certain underlying continuous random variables <span class="math inline">\(Y^*_i\)</span>, <span class="math inline">\(i=1,\dots,p\)</span>. The connection is made as follows: <span class="math display">\[
Y_i = \begin{cases}
0 &amp; \hphantom{\tau_{m-1}^{(i)} \leq \,\,} Y^*_i &lt; \tau_1^{(i)} \\
1 &amp;  \ \ \tau_{1}^{(i)} \leq  Y^*_i &lt; \tau_2^{(i)} \\
2 &amp;  \ \ \tau_{2}^{(i)} \leq  Y^*_i &lt; \tau_3^{(i)} \\
\vdots &amp;  \hphantom{\tau_{1}^{(i)} \leq \ \ \ } \vdots \\
m_i-1 &amp; \tau_{m_i-1}^{(i)} \leq Y^*_i .
\end{cases}
\]</span> Evidently, the model is invariant to a linear transformation: scaling and shifting the underlying variables <span class="math inline">\(Y_i^*\)</span> do not affect the outcome of the ordinal variable <span class="math inline">\(Y_i\)</span>. For this reason it is convenient to assume, for the purposes of model identifiability, a zero mean Gaussian distribution <span class="math inline">\({\mathbf Y}^* \sim \mathop{\mathrm{N}}_p({\mathbf 0},{\boldsymbol\Sigma}_{{\mathbf y}^*})\)</span>, where <span class="math inline">\({\boldsymbol\Sigma}_{{\mathbf y}^*}\)</span> is a correlation matrix.</p>
<p>The underlying continuous variables <span class="math inline">\({\mathbf Y}^*\)</span>, unlike their discrete counterparts <span class="math inline">\({\mathbf Y}\)</span>, are now suitable to be modelled using a factor analysis model. Here, the goal is to find a set of latent factors <span class="math inline">\({\boldsymbol\eta}= (\eta_1,\dots,\eta_q)^\top \in \mathbb{R}^q\)</span>, with <span class="math inline">\(q \ll p\)</span>, that sufficiently explain the covariance structure of the <span class="math inline">\(p\)</span>-dimensional variable space. This is achieved by the relationship <span class="math display">\[
{\mathbf Y}^* = {\boldsymbol\Lambda}{\boldsymbol\eta}+ {\boldsymbol\epsilon},
\]</span> where <span class="math inline">\({\boldsymbol\Lambda}\)</span> is a (often sparse) <span class="math inline">\(p \times q\)</span> matrix of factor loadings, and <span class="math inline">\({\boldsymbol\epsilon}\)</span> is a vector of residuals. Certain distributional assumptions are made, namely that <span class="math inline">\({\boldsymbol\eta}\sim \mathop{\mathrm{N}}_q({\mathbf 0},{\boldsymbol\Psi})\)</span> with <span class="math inline">\({\boldsymbol\Psi}\)</span> a correlation matrix, <span class="math inline">\({\boldsymbol\epsilon}\sim \mathop{\mathrm{N}}_p({\mathbf 0},{\boldsymbol\Theta}_{{\boldsymbol\epsilon}})\)</span> with <span class="math inline">\({\boldsymbol\Theta}_{{\boldsymbol\epsilon}} = {\mathbf I}- \mathop{\mathrm{diag}}({\boldsymbol\Lambda}{\boldsymbol\Psi}{\boldsymbol\Lambda}^\top)\)</span>, and that <span class="math inline">\(\mathop{\mathrm{Cov}}({\boldsymbol\eta},{\boldsymbol\epsilon}) = {\mathbf 0}\)</span>. Together, this implies that the polychoric correlation matrix of <span class="math inline">\({\mathbf Y}\)</span> is given by <span class="math display">\[
{\boldsymbol\Sigma}_{{\mathbf y}^*} = {\boldsymbol\Lambda}{\boldsymbol\Psi}{\boldsymbol\Lambda}^\top + {\boldsymbol\Theta}_{{\boldsymbol\epsilon}}.
\]</span> As a remark, the underlying variable approach is commonly employed in the context of confirmatory factor analysis (CFA) models due to the ease of modelling, though other approaches such as item response theory (IRT) models are also available.</p>
<p>For this factor analysis model, the parameters of interest are the non-zero entries <span class="math inline">\({\boldsymbol\lambda}\)</span> of the loading matrix <span class="math inline">\({\boldsymbol\Lambda}\)</span>, the unique non-diagonal entries <span class="math inline">\({\boldsymbol\rho}\)</span> in the factor correlation matrix <span class="math inline">\({\boldsymbol\Psi}\)</span>, and the thresholds <span class="math inline">\({\boldsymbol\tau}^{(i)} = (\tau_1^{(i)},\dots,\tau_{m_i-1}^{(i)})^\top\)</span> for each ordinal item <span class="math inline">\(Y_i\)</span>. Collectively, these parameters are denoted by <span class="math inline">\({\boldsymbol\theta}= ({\boldsymbol\lambda}^\top,{\boldsymbol\rho}^\top,{\boldsymbol\tau}^{(1)},\dots,{\boldsymbol\tau}^{(p)})^\top\)</span> belonging to some parameter space <span class="math inline">\({\boldsymbol\Theta}\)</span>.</p>
<p>Estimation…</p>
<ul>
<li>Full information (e.g.&nbsp;ML)</li>
<li>Limited information (e.g.&nbsp;composite likelihood, WLSMV, DWLS)</li>
</ul>
</section>
<section id="ligof-tests" class="level3">
<h3 class="anchored" data-anchor-id="ligof-tests">LIGOF tests</h3>
<p>Aenean placerat luctus tortor vitae molestie. Nulla at aliquet nulla. Sed efficitur tellus orci, sed fringilla lectus laoreet eget. Vivamus maximus quam sit amet arcu dignissim, sed accumsan massa ullamcorper. Sed iaculis tincidunt feugiat. Nulla in est at nunc ultricies dictum ut vitae nunc. Aenean convallis vel diam at malesuada. Suspendisse arcu libero, vehicula tempus ultrices a, placerat sit amet tortor. Sed dictum id nulla commodo mattis. Aliquam mollis, nunc eu tristique faucibus, purus lacus tincidunt nulla, ac pretium lorem nunc ut enim. Curabitur eget mattis nisl, vitae sodales augue. Nam felis massa, bibendum sit amet nulla vel, vulputate rutrum lacus. Aenean convallis odio pharetra nulla mattis consequat.</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-agresti2002categorical" class="csl-entry" role="listitem">
Agresti, Alan. 2002. <em>Categorical Data Analysis</em>. 2nd ed. Wiley Series in Probability and Statistics. New York: Wiley-Interscience.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>